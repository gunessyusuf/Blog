#nullable disable
using AppCore.Results.Bases;
using Business.Models;
using Business.Models.Account;
using Business.Services;
using Microsoft.AspNetCore.Authentication;
using Microsoft.AspNetCore.Authentication.Cookies;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;

//Generated by ScaffoldApp.
namespace MVC.Areas.Account.Controllers
{
    [Area("Account")]
    public class UsersController : Controller
    {
        // Add service injections here
        private readonly IAccountService _accountService;

        public UsersController(IAccountService accountService)
        {
            _accountService = accountService;
        }

        // GET: Account/Users/Login
        public IActionResult Login(string returnUrl) // giriş, returnUrl ile hangi sayfa üzerinden login'e geliniyorsa tekrar o sayfaya yönlendirilecek
        {
            AccountLoginModel model = new AccountLoginModel() // view'da UserName ve Password'ün boş, ReturnUrl'nin de aksiyona parametre olarak gelen
                                                              // returnUrl olacağı yeni bir model oluşturuyoruz
            {
                ReturnUrl = returnUrl
            };
            
            return View(model); // yukarıda new'lediğimiz modeli view'e gönderiyoruz
        }

        // POST: Account/Users/Login
        // To protect from overposting attacks, enable the specific properties you want to bind to.
        // For more details, see http://go.microsoft.com/fwlink/?LinkId=317598.
        [HttpPost]
        [ValidateAntiForgeryToken]
        public IActionResult Login(AccountLoginModel model) // giriş
        {
            if (ModelState.IsValid)
            {
                UserModel userResultModel = new UserModel();

				// UserModel tipindeki userResult'ı burada tanımlayıp new'liyoruz ki Login methodu  
				// başarılı olursa userResult referans tip olduğu için Login methodu içerisinde atansın 
				// ve bu methodda kullanabilelim, userResult içerisindeki Role referans özelliğini de new'liyoruz ki
				// methodda rolü de doldurabilelim
				Result result = _accountService.Login(model, userResultModel); // modeldeki kullanıcı adı ve şifreyi aktiflik durumuyla birlikte kontrol ediyoruz

                if (result.IsSuccessful) // eğer modeldeki kullanıcı adı ve şifreye sahip aktif kullanıcı varsa
				{

                    // Login methodunda doldurulan userResult objesinin istediğimiz özelliklerindeki verileri bir claim (talep) listesinde dolduruyoruz ki
                    // bu liste üzerinden şifreli bir şekilde bir cookie (çerez) oluşup client'a geri dönülsün ve kullanıcı bilgilerini içeren
                    // bu cookie üzerinden web uygulamamızda authorization (yetki kontrülü) yapabilelim,
                    // claim'lerde asla şifre gibi kritik veriler saklanmamalıdır
                    List<Claim> claims = new List<Claim>()
                    {
                        //new Claim("Name", userResultModel.UserName) // Claim Dictionary veri tipine benzer bir tipi ve o tipe karşılık değeri olan bir yapıdır,
                                                                      // constructor'ının ilk parametresi olan tipi elle yazmak yerine ClaimTypes üzerinden
                                                                      // kullanmak daha uygundur, ikinci parametre ise bu tipe atanmak istenen değerdir
                        new Claim(ClaimTypes.Name, userResultModel.UserName),

                        new Claim(ClaimTypes.Role, userResultModel.Role.Name),

                        new Claim(ClaimTypes.Sid, userResultModel.Id.ToString())
                    };

                    // oluşturduğumuz claim listesi üzerinden cookie authentication default'ları ile bir identity (kimlik) oluşturuyoruz
                    var identity = new ClaimsIdentity(claims, CookieAuthenticationDefaults.AuthenticationScheme);

                    // oluşturduğumuz kimlik üzerinden de MVC'de authentication (kimlik doğrulama) için kullanacağımız bir principal oluşturuyoruz 
                    var principal = new ClaimsPrincipal(identity);

                    // son olarak oluşturduğumuz principal üzerinden cookie authentication default'ları ile MVC'de kimlik giriş işlemini tamamlıyoruz,
                    // SignInAsync methodu bir asenkron method olduğu için sonunda görevin (Task) tamamlanması için Wait methodunu kullanmalıyız
                    HttpContext.SignInAsync(CookieAuthenticationDefaults.AuthenticationScheme, principal).Wait();

                    // giriş işlemi başarılı olduğu için kullanıcıyı ReturnUrl doluysa ReturnUrl üzerinden login'e geldiği controller ve action'a yönlendiriyoruz
                    if (!string.IsNullOrWhiteSpace(model.ReturnUrl))
                        return Redirect(model.ReturnUrl);
					
					return RedirectToAction("Index", "Home", new { area = "" }); // eğer ReturnUrl boşsa kullanıcıyı hoşgeldin view'ını
					                                                             // dönen Home controller -> Index action'ına area'sı olmadığı için
					                                                             // route value'da area = "" atayarak yönlendiriyoruz
					
				}

                ModelState.AddModelError("", result.Message);
            }
            // Add get related items service logic here to set ViewData if necessary and update null parameter in SelectList with these items
            return View(); // view'a modeli göndermedik çünkü kullanıcının herhangi bir hatalı girişi durumunda sıfırdan sayfada kullanıcı adı ve şifresini girmesini istedik
		}

        public IActionResult Logout() // çıkış
        {
            HttpContext.SignOutAsync(); // Login aksiyonu ile oluşan çerezi (cookie) kaldırır

            // projenin Home controller -> Index action'ı bir area'nın içerisinde olmadığı için area özelliğini içeren anonim tipteki objeyi
            // route value parametresi olarak ve "" atayarak oluşturuyoruz
            return RedirectToAction("Index", "Home", new { area = "" });
        }

        public IActionResult AccessDenied() // kullanıcı giriş yaptı ancak yetkisi olmayan bir controller action'ını çağırdı
        {
            return View("_Error", "Access is denied for this page!");
        }

        public IActionResult Register()
        {
            return View();
        }

        [HttpPost]
        [ValidateAntiForgeryToken]
        public IActionResult Register(AccountRegisterModel model)
        {
            if (ModelState.IsValid)
            {
                Result result = _accountService.Register(model);
                if (result.IsSuccessful)
                    return RedirectToAction(nameof(Login));
                ModelState.AddModelError("", result.Message);
            }
            return View(model);
        }
    }
}
